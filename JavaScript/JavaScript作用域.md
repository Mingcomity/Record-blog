# Javascript作用域

**作用域：一套设计良好的规则来存储变量，并且在这之后可以方便的寻炸到这些变量，这套规则就称为作用域。**

## 1.作用域是什么

> 注意：通常来说，Javascript归类为**“动态”或“解释执行”**语言，但事实上它是一门**编译语言。**

**编译原理：**

- 传统编译语言的流程

  1. **分词/词法分析**

     - 就是将由字符组成的字符串分解成有意义的代码块，这些代码块被称为**词法单元**。

       > 理解分词和词法分析的区别：主要差异在于词法单元的识别是通过 **有状态** 还是 **无状态** 的方式进行的

  2. **解析/语法分析**

     - 将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了语法结构的树，即**“抽象语法树”——AST**。

  3. **代码生成**

     - 将AST转换为可执行代码的过程称为代码生成。

- 对于JavaScript引擎来说

  1. 不会有大量的时间来优化，因为JS的编译过程不是发生在构建之前。
  2. 大部分情况下编译发生在代码执行前的几微秒（甚至更短）。

  > 所以任何JavaScript代码片段**在执行前都要进行编译**。

**理解作用域：**

- 引擎
- 编译器
- 作用域

```js
var a = 1205;
```

1. 遇到 `var a` ，编译器会先询问是否有一个名称为a的变量在同一个作用域中，如果没有则要求作用域在当前的作用域集合中声明一个变量，命名为a。
2. 然后，编译器会为引擎生成运行时所需要的代码，这些代码被用来处理 `a = 2` 这个赋值操作。

即首先**编译器**会在当前作用域中声明一个变量（如果在这之前没有声明过），然后**引擎**会在作用域中查找该变量，如果能找到就会对它赋值。



**引申两个概念：**

- LHS查询

  - 查找某个变量的容器本身，即赋值操作的目标是谁

- RHS查询

  - 查找某个变量的值，即取到它的源值。

  ```js
  function foo(a) {
  	console.log( a );
  }
  foo(2);
  ```

  ![对话](https://mdimages-1314620922.cos.ap-guangzhou.myqcloud.com/Maekdownimages/Node.js/%E5%AF%B9%E8%AF%9D.jpg)



**作用域嵌套：**

> 当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。

- **遍历嵌套作用域的规则：**

> 引擎从当前的执行作用域开始查找变量，如果找不到就会向上一级继续查找，抵达最外层的全局作用域时，无论有没有找到，都会停止。LHS和RHS都会按照这个规则查找。

- **LHS和RHS发出异常的区别：**

> - RHS查询在所有嵌套的作用域都查到不到时，引擎就会抛出 `ReferenceError` 类型的错误。
>   - 如果找到了，但是对这个变量进行不合理的操作，例如 `undefined()` 就会抛出 `TypeError` 异常。
> - LHS查询如果在顶层（全局作用域）也没有找到，就会创建一个具有该名称的变量。（非严格模式下，因为严格模式是禁止自动或隐式的插件全局变量，同时也会抛出一个  `ReferenceError` 类型的错误）。

## 2.词法作用域

> 词法作用域意味着作用域是由书写代码时函数声明的位置来决定的。

词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的，因此但词法分析器对代码进行处理时会保持作用域不变。（但也存在一些欺骗词法作用域的方法）

- 欺骗词法
  - eval
    - 还有如 `seTimeout、setInterval、new Function `这些
  - with

这两个机制都会引起引擎无法在编译时对作用域查找进行优化，所以使用如何一个机制都会导致代码运行变慢，所以不要使用它们。

## 3.函数作用域和块作用域

JavaScript作用域为静态作用域，也称词法作用域。

> **词法作用域**就是定义在词法阶段（注意上面所讲的编译过程）的作用域。

**函数作用域：**

- 指的是属于这个函数的全部变量都可以在整个函数的范围内使用及复用。

- 函数作用域的实践

  - 立即执行函数表达式

    > 功能上一样，全凭个人喜好

    ```js
    (function(){...})();
    (function(){...}());
    ```

    

**块作用域：**

- 在ES6之前表面上看JavaScript并没有块作用域的相关功能，但实际上严格模式下的`eval()`、`with` 关键字、 `tyr/catch` 中的catch分句都会隐式的创建块级作用域。
- 在ES6之后，出现的 `let const` 声明可以用来创建块级作用域



参考：

```
《你不知道的Javascript》
《Javascript高级程序设计》
https://blog.touchczy.top/#/JavaScript/%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE
```

